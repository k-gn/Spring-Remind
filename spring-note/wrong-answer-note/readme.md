# Spring Wrong Note

### 컨벤션 교정
>축약어 
  - 대문자로 표현하지 않는다.
    - userId (Good)
    - userID (Bad)
    - OAuth 같은 애매한 축약어는 유명한 오픈소스 같은걸 참조하면 좋다 (스프링 시큐리티)
  - 왠만하면 축약보단 온전한 단어를 사용하는 것을 지향하자.
- 클래스 이름은 가급적 단어 조합은 3개 이하가 좋다.


>동사
  - 유의미한 단어를 사용하자
    - Simple, Light, Base, Util ... 등의 애매한 단어를 지양하자.
    - ~Creater, ~Factory ... 같이 구체적이고 목적에 맞는 이름을 사용하자.
    - ~Util 이란 이름은 사용할 경우 온갖 static 메소드들이 모인다.
  - get / find 를 구분하자.
    - Return T : Get
    - Return Optional T : Find
  - isExist (동사를 반복 = 없는 말) -> exist
  - get 을 남발하지 말자 (갖고있는 속성 정보를 제공하는 의미임)
    - 따라서 getSumPrice -> sumPrice
  - 검증이 필요할 때
    - verify / validate / check / is
    

> 롬복
  - 강력한 기능이긴 하지만 캡슐화를 망치는 주범이다.
  - getter, setter 를 남발하지 말자.
  - 객체를 수동적으로 만드는 건 좋지 않다.
    - 수동적 = 직접 데이터를 저장하고, 보여준다.
    - 능동적 = 객체에게 일을 시킨다. (TDA 원칙)


> 가독성
  - 주석은 필요할 때만 사용하자.
    - 유의미한 메소드 읽기좋은 코드를 만들자.
  - Optional을 자주 사용하자.
    - 코드의 완성도를 높이고 NPE를 방지한다.
  - Collection.Map을 남발하지 말자.
    - 활용도가 높아 분리하지 않고 주구장창 Map 만 쓰게 된다.
    - 즉, 본인만 이해할 수 있는 코드가 된다.
    - 사용할 경우 현재 Scope를 벗어나지 말자.


> 관습
  - 범위(range) : [start~, end~]
    - 시작은 포함, 끝은 미포함


> 자바진영 스타일 가이드 : **구글 코드 스타일 가이드 추천**
---

## SOLID
### Single Responsibility (단일 책임 원칙)
    - 어떤 클래스나 모듈은 변경하려는 이유를 단 한가지만 가져야 한다.
    - 코드라인이 100줄을 넘어간다면 의심해봐라
### Open-Close Principle (개방 폐쇠 원칙)
    - 확장엔 열려있고, 수정엔 닫혀있어야 한다.
    - 유연성, 재사용성, 유지보수성을 위한 원칙
    - 추상화(인터페이스화)가 부족한 경우 나타남
### Liskov Substitution (리스코프 치환 원칙)
    - 자료형 S가 자료형 T의 하위형이라면, 필요한 속성 변경없이 T의 객체를 S의 객체로 교체할 수 있어야 한다.
    - 상위클래스와 하위클래스 사이의 계약이 깨지는 경우
    - 상속은 신경쓸게 많고, 고비용이 들어가는 작업이라 가급적 피하는게 좋다.
### Interface Segregation (인터페이스 분리 원칙)
    - 자신이 사용하지 않는 메소드에 의존하지 않아야 한다.
    - 인터페이스를 분리/조립 하듯 만들이 않은 경우 발생
    - 인터페이스 : 이 기능을 사용하고 싶으면, 이 방법을 사용하세요~ 라고 알려주는 것 = public method
      - API도 인터페이스다.
### Dependency Inversion (의존성 역전 원칙)
    - 상위 모듈은 하위 모듈에 의존하면 안된다.
    - 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
    - 추상화는 세부사항에 의존하면 안된다. (반대여야 한다.)
    - 구현체에 바로 의존할 경우 문제 발생
    - 느슨한 결합도로 유연, 재사용성 및 코드의 단순화
    - 의존성 - 커플링, 다른 객체나 함수를 사용하는 상태
    - 의존성 주입 - 필요한 값을 외부에서 의존성을 넣어주는 것 (단, 의존성이 사라진게 아닌 약해진 것)
    - 의존성 역전 - 화살표 방향을 반대로 바꾸는 테크닉
    - 추상화는 좋은 방법론이지만 개발 비용을 증가시킨다. 
      - 추상화 여부는 개발자가 매번 판단해야 한다.
    - 생성자 주입이 7개, 파라미터 주입이 4개가 넘어간다면 클래스/메소드 분할을 고려하자.
  
### 의존성을 추상화 시키는 방법
    1. 의존성을 드러내라
      - 내부에 감춰진 의존성으로 인해 디버깅이 힘들다. 
      - 테스트하기에도 난해하다.
        - 테스트가 쉬운 코드는 좋은 코드.
        - 의존성을 제대로 처리하지 않으면 테스트하기 어렵다.
      - 시간, 랜덤값 같은 실행마다 변하는 값에 대한 의존성
    2. 변하는 값은 주입 받아라.
    3. 변하는 값을 추상화 시켜라.
       - 런타임과 컴파일타임의 의존성을 다르게 하는 것
       - ex. ClockHolder
![img.png](img.png)

### CQRS
    - Command and Query Responsibility Segregation
    - 명령과 질의의 책임 분리
      - 명령 : 일을 시키는 메소드 (객체 상태를 변경하며 반환값이 없다.)
      - 질의 : 상태를 물어보는 메소드 (객체 상태를 변경시키면 안되며, 값을 반환 한다.)
    - 메소드를 명령과 질의로 나누자 (더 넓게는 클래스 까지)